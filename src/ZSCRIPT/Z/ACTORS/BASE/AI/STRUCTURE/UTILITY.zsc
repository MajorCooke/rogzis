enum ZEUtilityType{
    UTL_LINEAR,
    UTL_POLYNOMIAL,
    UTL_LOGISTIC,
    UTL_LOGIT,
}

class ZUtility{
    Array<ZUtilityAxis> Axes;

    bool Push(ZUtilityAxis Axis){
        if(Axes.Find(Axis)!=Axes.Size()){
            ZManager.Error("Axis already exists", ERR_ERROR);
            return false;
        }
        return Axes.Push(Axis);
    }

    double Get(ZMatrix2 Xs){
        if(Xs.Height()!=Axes.Size()){
            ZManager.Error("Incorrect Number of Axes\nIs: "..Xs.Height()..", Should Be: "..Axes.Size(), ERR_ERROR);
            return double.NaN;
        }
        double Score=1;
        for(int i=0; i<Axes.Size(); i++)
            Score*=Axes[i].Get(Xs.Get(i));
        return Score*(1+(1-1/Axes.Size())*(1-Score));
    }
}

class ZUtilityAxis{
    bool XSign,
         YSign;

    byte Degree;

    double Misc;

    ZEUtilityType Type;

    ZMapper Mapper;

    static
    ZUtilityAxis Create(ZEUtilityType Type, double Min, double Max, double Misc=0, int XSign=1, int YSign=1){
        ZUtilityAxis Function=new('ZUtilityAxis');
        Function.XSign=XSign>0;
        Function.YSign=YSign>0;
        Function.Type=Type;
        Function.Mapper=ZMapper.Create(Min, Max);
        if(Misc==0){
            switch(Type){
                case UTL_LINEAR: break;
                case UTL_POLYNOMIAL:
                    Misc=2;
                    break;
                case UTL_LOGISTIC:
                case UTL_LOGIT:
                    Misc=.75;
                    break;
            }
        }
        Function.Misc=Misc;
        return Function;
    }

    double Get(double X){
        X=Mapper.NormRangeMap(X);
        if(!XSign)
            X=1-X;
        double Y;
        switch(Type){
            case UTL_LINEAR:
                Y=X;
                break;
            case UTL_POLYNOMIAL:
                Y=X**Misc;
                break;
            case UTL_LOGISTIC:
                Y=1/(1+exp(-Misc*(12*X-6)));
                break;
            case UTL_LOGIT:
                Y=log(X/(1-X))/(12*Misc)+.5;
                break;
        }
        if(!YSign)
            Y=1-Y;
        return Clamp(Y, 0, 1);
    }
}