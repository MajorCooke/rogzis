class ZPerceptron{
    private
    uint Inputs,
         Hiddens,
         Outputs;

    private
    double LearningRate;

    private
    ZMatrix In2Hid,
            Hid2Out,
            HidBias,
            OutBias;

    private
    ZGaussian StdNormDist;

    static
    ZPerceptron Create(uint Inputs, uint Hiddens, uint Outputs, double LearningRate=.1)
    {return new("ZPerceptron").Init(Inputs, Hiddens, Outputs, LearningRate);}

    private
    ZPerceptron Init(uint Inputs, uint Hiddens, uint Outputs, double LearningRate){
        self.Inputs=Inputs;
        self.Hiddens=Hiddens;
        self.Outputs=Outputs;
        In2Hid=ZMatrix.Create(Hiddens, Inputs);
        StdNormDist=ZGaussian.Create(ZManager.MapSeed(self));
        for(int i=0; i<In2Hid.Height(); i++)
            for(int j=0; j<In2Hid.Width(); j++)
                In2Hid.Set(i, j, StdNormDist.Generate());
        Hid2Out=ZMatrix.Create(Outputs, Hiddens);
        for(int i=0; i<Hid2Out.Height(); i++)
            for(int j=0; j<Hid2Out.Width(); j++)
                Hid2Out.Set(i, j, StdNormDist.Generate());
        HidBias=ZMatrix.Create(Hiddens, 1);
        for(int i=0; i<HidBias.Height(); i++)
            HidBias.Set(i, 0, StdNormDist.Generate());
        OutBias=ZMatrix.Create(Outputs, 1);
        for(int i=0; i<OutBias.Height(); i++)
            OutBias.Set(i, 0, StdNormDist.Generate());
        self.LearningRate=LearningRate;
        return self;
    }

    ZPerceptron Train(ZMatrix InputVals, ZMatrix TargetVals){
        for(int i=0; i<InputVals.Height(); i++){
            ZMatrix Inputs=ZMatrix.Create(InputVals.Width(), 1),
                    Targets=ZMatrix.Create(TargetVals.Width(), 1);
            for(int j=0; j<Inputs.Height(); j++)
                Inputs.Set(j, 0, InputVals.Get(i, j));
            for(int j=0; j<Targets.Height(); j++)
                Targets.Set(j, 0, TargetVals.Get(i, j));
            ZMatrix Hiddens=Activation(In2Hid.MMultiply(Inputs).Add(HidBias)),
                    Outputs=Activation(Hid2Out.MMultiply(Hiddens).Add(OutBias)),
                    OutputErrors=Targets.Subtract(Outputs),
                    Gradients=Activation(Outputs, true)
                             .Multiply(OutputErrors)
                             .SMultiply(LearningRate),
                    DeltaOutput=Gradients.MMultiply(Hiddens.Transpose()),
                    HiddenGradients=Activation(Hiddens, true)
                                   .Multiply(Hid2Out.Transpose().MMultiply(OutputErrors))
                                   .SMultiply(LearningRate),
                    DeltaHidden=HiddenGradients.MMultiply(Inputs.Transpose());
            Hid2Out=Hid2Out.Add(DeltaOutput);
            OutBias=OutBias.Add(Gradients);
            In2Hid=In2Hid.Add(DeltaHidden);
            HidBias=HidBias.Add(HiddenGradients);
        }
        return self;
    }

    ZMatrix Get(ZMatrix Inputs)
    {return Activation(Hid2Out.MMultiply(Activation(In2Hid.MMultiply(Inputs).Add(HidBias))).Add(OutBias));}

    private
    ZMatrix Activation(ZMatrix Inputs, bool Derivative=false){
        ZMatrix Outputs=ZMatrix.Create(Inputs.Height(), Inputs.Width());
        for(int Row=0; Row<Inputs.Height(); Row++)
            for(int Column=0; Column<Inputs.Width(); Column++)
                Outputs.Set(Row, Column, Sigmoid(Inputs.Get(Row, Column), Derivative));
        return Outputs;
    }

    private
    double Sigmoid(double X, bool Derivative=false){
        if(Derivative)
            return X*(1-X);
        return 1/(1+ZCalc.E**-X);
    }
}