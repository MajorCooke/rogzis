struct ZCalc{
    ///////////////
    // Constants //
    ///////////////
    const E=2.718281828459;
    const PI=3.14159265359;

    /////////////
    // Numbers //
    /////////////
    static
    bool Equals(double FirstValue, double SecondValue, double Epsilon=double.Epsilon)
    {return Abs(FirstValue-SecondValue)<=Epsilon;}

    static
    int ShiftOf(int Value){
        int Shifts=0;
        while(Value>1){
            Value>>=1;
            Shifts++;
        }
        return Shifts;
    }

    static
    int Sign(double Value)
    {return !Equals(Value, 0)*((Value<0)?-1:1);}

    static
    double TransferSign(double Value, double Sign)
    {return Abs(Value)*Sign(Sign);}

    static
    int Alternate(int n, bool Offset=false)
    {return -1**(n-Offset);}

    static
    int Round(double Value)
    {return (Value%1>=.5)?Ceil(Value):Floor(Value);}

    static
    double NormRange(double Value)
    {return Clamp(Value, 0, 1);}

    static
    double NormRangeMap(double Value, double Start, double End)
    {return NormRange((Value-Start)/(End-Start));}

    static
    double ANormRangeMap(double Value, double Start, double End)
    {return clamp(Value*(End-Start)+Start, Start, End);}

    static
    int IRangeMap(int Value, int OldStart, int OldEnd, int NewStart, int NewEnd)
    {return ANormRangeMap(NormRange((Value-OldStart)/(OldEnd-OldStart)), NewStart, NewEnd);}

    static
    double DRangeMap(double Value, double OldStart, double OldEnd, double NewStart, double NewEnd)
    {return ANormRangeMap(NormRangeMap(Value, OldStart, OldEnd), NewStart, NewEnd);}

    static
    double AsymptoticMean(double X, double Target, double Weight=.1)
    {return (Target-X)*(1-Weight);}

    static
    int Factorial(int N){
        if(N>0)return N*Factorial(N-1);
        else if(N==0)return 1;
        else ZManager.Error("Attempted factorial of a negative number", ERR_FATAL);
        return 0;
    }

    static
    int nCr(int N, int K)
    {return Factorial(N)/(Factorial(K)*Factorial(N-K));}

    static
    int NthTriNumber(int N)
    {return N*(N+1)/2;}

    static
    double Bernstein(double Time, int N, int V)
    {return nCr(N, V)*Time**V*(1-Time)**(N-V);}

    static
    double Lerp(double Time, double Start=0, double End=1){
        Time=NormRange(Time);
        return (1-Time)*Start+Time*End;
    }

    static
    double SmoothStart(double Time, double Start=0, double End=1, double Degree=2)
    {return ANormRangeMap(NormRangeMap(Time, Start, End)**Degree, Start, End);}

    static
    double SmoothStop(double Time, double Start=0, double End=1, double Degree=2)
    {return ANormRangeMap(1-(1-NormRangeMap(Time, Start, End))**Degree, Start, End);}

    static
    double SmoothStep(double Time, double Start=0, double End=1, double Degree=2)
    {return Lerp(Time, SmoothStart(Time, Start, End, Degree), SmoothStop(Time, Start, End, Degree));}

    /////////////
    // Vector2 //
    /////////////
    static
    Vector2 V2Lerp(double Time, Vector2 Start=(0, 0), Vector2 End=(1, 1)){
        Time=NormRange(Time);
        return (1-Time)*Start+Time*End;
    }

    static
    Vector2 V2SmoothStart(double Time, Vector2 Start=(0, 0), Vector2 End=(1, 1), double Degree=2)
    {return (SmoothStart(Time, Start.X, End.X, Degree), SmoothStart(Time, Start.Y, End.Y, Degree));}

    static
    Vector2 V2SmoothStop(double Time, Vector2 Start=(0, 0), Vector2 End=(1, 1), double Degree=2)
    {return (SmoothStop(Time, Start.X, End.X, Degree), SmoothStop(Time, Start.Y, End.Y, Degree));}

    static
    Vector2 V2SmoothStep(double Time, Vector2 Start=(0, 0), Vector2 End=(1, 1), double Degree=2)
    {return (SmoothStep(Time, Start.X, End.X, Degree), SmoothStep(Time, Start.Y, End.Y, Degree));}

    static
    Vector2 V2Bezier(double Time, ZMatrix2 Points, bool Row=true){
        Vector2 Total=(0, 0);
        for(int i=0; i<(Row)?Points.Height()/2:Points.Width()/2; i++)
            Total+=Points.V2Get(i*Row, i*!Row, Row)*Bernstein(Time, Points.Height(), i);
        return Total;
    }

    static
    bool IsInTriangle(Vector2 Point, Vector2 A, Vector2 B, Vector2 C){
        Vector2 C2A=C-A,
                B2A=B-A,
                P2A=Point-A;
        int C2C=C2A dot C2A,
            C2B=C2A dot B2A,
            C2P=C2A dot P2A,
            B2B=B2A dot B2A,
            B2P=B2A dot P2A,
            InverseDenominator=1/(C2C*B2B-C2B**2),
            U=InverseDenominator*(B2B*C2P-C2B*B2P),
            V=InverseDenominator*(C2C*B2P-C2B*C2P);
            return U>=0 && V>=0 && U+V<1;
    }

    static
    Vector2 V2CenterOfMass(Vector2 A, Vector2 B, Vector2 C, double AWeight=1, double BWeight=1, double CWeight=1)
    {return (A*AWeight+B*BWeight+C*CWeight)/(AWeight+BWeight+CWeight);}

    /////////////
    // Vector3 //
    /////////////
    static
    Vector3 V3Lerp(double Time, Vector3 Start=(0, 0, 0), Vector3 End=(1, 1, 1)){
        Time=NormRange(Time);
        return (1-Time)*Start+Time*End;
    }

    static
    Vector3 V3SmoothStart(double Time, Vector3 Start=(0, 0, 0), Vector3 End=(1,1, 1), double Degree=2)
    {return (SmoothStart(Time, Start.x, End.x, Degree), SmoothStart(Time, Start.y, End.y, Degree), SmoothStart(Time, Start.z, End.z, Degree));}

    static
    Vector3 V3SmoothStop(double Time, Vector3 Start=(0, 0, 0), Vector3 End=(1, 1, 1), double Degree=2)
    {return (SmoothStop(Time, Start.x, End.x, Degree), SmoothStop(Time, Start.y, End.y, Degree), SmoothStop(Time, Start.z, End.z, Degree));}

    static
    Vector3 V3SmoothStep(double Time, Vector3 Start=(0, 0, 0), Vector3 End=(1, 1, 1), double Degree=2)
    {return (SmoothStep(Time, Start.x, End.x, Degree), SmoothStep(Time, Start.y, End.y, Degree), SmoothStep(Time, Start.z, End.z, Degree));}

    static
    Vector3 V3CenterOfMass(Vector3 A, Vector3 B, Vector3 C, double AWeight=1, double BWeight=1, double CWeight=1)
    {return (A*AWeight+B*BWeight+C*CWeight)/(AWeight+BWeight+CWeight);}

    /////////////////
    // ZQuaternion //
    /////////////////
    static
    ZQuaternion ZQLerp(double Time, ZQuaternion Start, ZQuaternion End)
    {return Start.SMultiply(1-Time).Add(End.SMultiply(Time)).Unit();}

    static
    ZQuaternion ZQSlerp(double Time, ZQuaternion Start, ZQuaternion End){
        double SEDot=Start.DotProduct(End);
        ZQuaternion Temp;
        if(SEDot<0){
            SEDot=-SEDot;
            Temp=End.Negative();
        }else Temp=End;
        if(SEDot<.95){
            double Angle=ACos(SEDot);
            return Start.SMultiply(Sin(Angle*(1-Time))).Add(Temp.SMultiply(Sin(Angle*Time))).SDivide(Sin(Angle));
        }else return ZQLerp(Time, Start, Temp);
    }
}

class ZMapper{
    double Min,
           Max;

    static
    ZMapper Create(double Min, double Max){
        ZMapper Mapper=new('ZMapper');
        Mapper.Min=Min;
        Mapper.Max=Max;
        return Mapper;
    }

    double NormRangeMap(double Value)
    {return ZCalc.NormRange((Value-Min)/(Max-Min));}

    double ANormRangeMap(double Value)
    {return clamp(Value*(Max-Min)+Min, Min, Max);}
}

class ZLeftInterpolator{
    protected
    int CurrentValue;

    static
    ZLeftInterpolator Create(int DesiredValue){
        ZLeftInterpolator Interpolator = new('ZLeftInterpolator');
        Interpolator.Reset(DesiredValue);
        return Interpolator;
    }

    void Reset(int DesiredValue)
    {CurrentValue=DesiredValue;}

    // This must be called peroiodically in the status bar's Tick function.
    // Do not call this in the Draw function because that may skip some frames!
    void Update(int DesiredValue){
        for(int i=9; i>=0; i--){
            int Place=10**i;
            if(CurrentValue/Place>DesiredValue/Place){
                CurrentValue-=Place;
                break;
            }else if(CurrentValue/Place<DesiredValue/Place){
                CurrentValue+=Place;
                break;
            }
        }
    }

    // This must be called in the draw function to retrieve the value for output.
    int GetValue() const
    {return CurrentValue;}
}