const E=2.718281828459;
const PI=3.14159265359;

struct ZCalc{
	/////////////
	// Numbers //
	/////////////
	static
	bool Equals(double FirstValue, double SecondValue, double Epsilon=double.Epsilon)
	{return abs(FirstValue-SecondValue)<=Epsilon;}

	static
	int ShiftOf(int Value){
		if(Value==0)return 0;
		int Shifts=0;
		while(Value>1){
			Value>>=1;
 			Shifts++;
		}
		return Shifts;
	}

	static
	int Sign(double Value)
	{return (Equals(Value, 0))?0:(Value<0)?-1:1;}

	static
	double TransferSign(double Value, double Sign)
	{return abs(Value)*Sign(Sign);}

	static
	int Alternate(int n, bool Offset=false)
	{return -1**(n-Offset);}

	static
	double NormalRangeMap(double Value, double Start, double End)
	{return clamp((Value-Start)/(End-Start), 0, 1);}

	static
	double AbnormalRangeMap(double Value, double Start, double End)
	{return clamp(Value*(End-Start)+Start, Start, End);}

	static
	int IRangeMap(int Value, int OldStart, int OldEnd, int NewStart, int NewEnd)
	{return AbnormalRangeMap(NormalRangeMap(Value, OldStart, OldEnd), NewStart, NewEnd);}

	static
	double DRangeMap(double Value, double OldStart, double OldEnd, double NewStart, double NewEnd)
	{return AbnormalRangeMap(NormalRangeMap(Value, OldStart, OldEnd), NewStart, NewEnd);}

	static
	double AMean(ZArray_String Array){
		double Total=0;
		for(int i=0; i<Array._.Size(); i++)
			Total+=Array._[i].ToDouble();
		return Total/Array._.Size();
	}

	static
	double GMean(ZArray_String Array){
		double Total=1;
		for(int i=0; i<Array._.Size(); i++)
			Total*=Array._[i].ToDouble();
		return Total**(1/Array._.Size());
	}

	static
	double HMean(ZArray_String Array){
		double Total=0;
		for(int i=0; i<Array._.Size(); i++)
			Total+=1/Array._[i].ToDouble();
		return Array._.Size()/Total;
	}

	static
	int Factorial(int N){
		if(N>0)return N*Factorial(N-1);
		else if(N==0)return 1;
		else ZManager.Error("Attempted factorial of a negative number", ERR_FATAL);
		return 0;
	}

	static
	int nCr(int N, int K)
	{return Factorial(N)/(Factorial(K)*Factorial(N-K));}

	static
	double Bernstein(int X, int N, int V)
	{return nCr(N, V)*X**V*(1-X)**(N-V);}

	static
	double Lerp(double Time, double Start=0, double End=1){
		Time=clamp(Time, 0, 1);
		return (1-Time)*Start+Time*End;
	}

	static
	double SmoothStart(double Time, double Start=0, double End=1, double Degree=2)
	{return AbnormalRangeMap(NormalRangeMap(Time, Start, End)**Degree, Start, End);}

	static
	double SmoothStop(double Time, double Start=0, double End=1, double Degree=2)
	{return AbnormalRangeMap(1-(1-NormalRangeMap(Time, Start, End))**Degree, Start, End);}

	static
	double SmoothStep(double Time, double Start=0, double End=1, double Degree=2)
	{return Lerp(Time, SmoothStart(Time, Start, End, Degree), SmoothStop(Time, Start, End, Degree));}

	/////////////
	// Vector2 //
	/////////////
	static
	}

	static
	Vector2 V2Lerp(double Time, Vector2 Start=(0, 0), Vector2 End=(1, 1)){
		Time=clamp(Time, 0, 1);
		return (1-Time)*Start+Time*End;
	}

	static
	Vector2 V2SmoothStart(double Time, Vector2 Start=(0, 0), Vector2 End=(1, 1), double Degree=2)
	{return (SmoothStart(Time, Start.X, End.X, Degree), SmoothStart(Time, Start.Y, End.Y, Degree));}

	static
	Vector2 V2SmoothStop(double Time, Vector2 Start=(0, 0), Vector2 End=(1, 1), double Degree=2)
	{return (SmoothStop(Time, Start.X, End.X, Degree), SmoothStop(Time, Start.Y, End.Y, Degree));}

	static
	Vector2 V2SmoothStep(double Time, Vector2 Start=(0, 0), Vector2 End=(1, 1), double Degree=2)
	{return (SmoothStep(Time, Start.X, End.X, Degree), SmoothStep(Time, Start.Y, End.Y, Degree));}

	static
	Vector2 V2BezierCurve(int Time, int N, int I, ZArray_String Points){
		Vector2 Total=(0, 0);
		for(int j=0; j<Points._.Size(); j++)
			Total+=(Points._[j].ToDouble(), Points.__[j].ToDouble())*Bernstein(Time, N, I);
		return Total;
	}

	static
	bool IsInTriangle(Vector2 Point, Vector2 A, Vector2 B, Vector2 C){
		Vector2 C2A=C-A,
				B2A=B-A,
				P2A=Point-A;
		int C2C=C2A dot C2A,
			C2B=C2A dot B2A,
			C2P=C2A dot P2A,
			B2B=B2A dot B2A,
			B2P=B2A dot P2A,
			InverseDenominator=1/(C2C*B2B-C2B**2),
			u=InverseDenominator*(B2B*C2P-C2B*B2P),
			v=InverseDenominator*(C2C*B2P-C2B*C2P);
			return u>=0 && v>=0 && u+v<1;
	}

	static
	Vector2	V2CenterOfMass(Vector2 A, Vector2 B, Vector2 C, double AWeight=1, double BWeight=1, double CWeight=1)
	{return (A*AWeight+B*BWeight+C*CWeight)/(AWeight+BWeight+CWeight);}

	/////////////
	// Vector3 //
	/////////////
	static
	Vector3 V3Lerp(double Time, Vector3 Start=(0, 0, 0), Vector3 End=(1, 1, 1)){
		Time=clamp(Time, 0, 1);
		return (1-Time)*Start+Time*End;
	}

	static
	Vector3 V3SmoothStart(double Time, Vector3 Start=(0, 0, 0), Vector3 End=(1,1, 1), double Degree=2)
	{return (SmoothStart(Time, Start.x, End.x, Degree), SmoothStart(Time, Start.y, End.y, Degree), SmoothStart(Time, Start.z, End.z, Degree));}

	static
	Vector3 V3SmoothStop(double Time, Vector3 Start=(0, 0, 0), Vector3 End=(1, 1, 1), double Degree=2)
	{return (SmoothStop(Time, Start.x, End.x, Degree), SmoothStop(Time, Start.y, End.y, Degree), SmoothStop(Time, Start.z, End.z, Degree));}

	static
	Vector3 V3SmoothStep(double Time, Vector3 Start=(0, 0, 0), Vector3 End=(1, 1, 1), double Degree=2)
	{return (SmoothStep(Time, Start.x, End.x, Degree), SmoothStep(Time, Start.y, End.y, Degree), SmoothStep(Time, Start.z, End.z, Degree));}

	static
	Vector3	V3CenterOfMass(Vector3 A, Vector3 B, Vector3 C, double AWeight=1, double BWeight=1, double CWeight=1)
	{return (A*AWeight+B*BWeight+C*CWeight)/(AWeight+BWeight+CWeight);}

	/////////////////
	// ZQuaternion //
	/////////////////
	static
	ZQuaternion ZQLerp(double Time, ZQuaternion Start, ZQuaternion End)
	{return Start.SMultiply(1-Time).Add(End.SMultiply(Time)).Unit();}

	static
	ZQuaternion ZQSlerp(double Time, ZQuaternion Start, ZQuaternion End){
		double SEDot=Start.DotProduct(End);
		ZQuaternion Temp;
		if(SEDot<0){
			SEDot=-SEDot;
			Temp=End.Negative();
		}else Temp=End;
		if(SEDot<.95){
			double Angle=ACos(SEDot);
			return Start.SMultiply(Sin(Angle*(1-Time))).Add(Temp.SMultiply(Sin(Angle*Time))).SMultiply(1/Sin(Angle));
		}else return ZQLerp(Time, Start, Temp);
	}
}

class ZQuaternion{
	private
	double W, X, Y, Z;

	static
	ZQuaternion Create(double W, double X, double Y, double Z)
	{return new("ZQuaternion").Init(W, X, Y, Z);}

	static
	ZQuaternion Zero()
	{return Create(0, 0, 0, 0);}

	static
	ZQuaternion Identity()
	{return Create(1, 0, 0, 0);}

	static
	ZQuaternion FromAngleAxis(double Angle, Vector3 Axis){
		Angle*=.5;
		Axis=Sin(Angle)*Axis.Unit();
		return Create(Cos(Angle), Axis.x, Axis.y, Axis.z);
	}

	static
	ZQuaternion FromEulerAngles(double Yaw, double Pitch, double Roll)
	{return new("ZQuaternion").SetEulerAngles(Yaw, Pitch, Roll);}

	private
	ZQuaternion Init(double W, double X, double Y, double Z){
		self.W=W;
		self.X=X;
		self.Y=Y;
		self.Z=Z;
		return self;
	}

	ZQuaternion SetEulerAngles(double Yaw, double Pitch, double Roll)
	{return Equal(FromAngleAxis(Yaw, (0, 0, 1)).QMultiply(FromAngleAxis(Pitch, (0, 1, 0))).QMultiply(FromAngleAxis(Roll, (1, 0, 0))));}

	double Length() const
	{return sqrt(LengthSquared());}

	double LengthSquared() const
	{return W**2+X**2+Y**2+Z**2;}

	ZQuaternion Negative() const
	{return Create(-W, -X, -Y, -Z);}

	ZQuaternion Unit() const
	{return SMultiply(1/Length());}

	ZQuaternion Inverse() const
	{return Conjugate().SMultiply(1/LengthSquared());}

	ZQuaternion Conjugate() const
	{return Create(W, -X, -Y, -Z);}

	ZQuaternion Add(ZQuaternion Other) const
	{return Create(W+Other.W, X+Other.X, Y+Other.Y, Z+Other.Z);}

	ZQuaternion Subtract(ZQuaternion Other) const
	{return Add(Other.Negative());}

	ZQuaternion SMultiply(double Multiplier) const
	{return Create(W*Multiplier, X*Multiplier, Y*Multiplier, Z*Multiplier);}

	ZQuaternion QMultiply(ZQuaternion Other) const
	{return Create(W*Other.W-X*Other.X-Y*Other.Y-Z*Other.Z,
				   W*Other.X+X*Other.W+Y*Other.Z-Z*Other.Y,
				   W*Other.Y+Y*Other.W+Z*Other.X-X*Other.Z,
				   W*Other.Z+Z*Other.W+X*Other.Y-Y*Other.X);}

	double DotProduct(ZQuaternion Other) const
	{return W*Other.W+X*Other.X+Y*Other.Y+Z*Other.Z;}

	ZQuaternion Equal(ZQuaternion Other){
		W=Other.W;
		X=Other.X;
		Y=Other.Y;
		Z=Other.Z;
		return self;
	}

	bool Equals(ZQuaternion Other) const
	{return ZCalc.Equals(W, Other.W) && ZCalc.Equals(X, Other.X) && ZCalc.Equals(Y, Other.Y) && ZCalc.Equals(Z, Other.Z);}

	bool IsZero() const
	{return ZCalc.Equals(LengthSquared(), 0);}

	bool IsIdentity() const
	{return Equals(Identity());}

	double, double, double GetEulerAngles() const{
		double SinP=2*(W*Y-Z*X),
			   YSquared=Y**2,
			   Pitch=(abs(SinP)>=1)?ZCalc.TransferSign(90, SinP):ASin(SinP);
		if(abs(Pitch)>=89)return 2*ATan2(X, W), Pitch, 0;
		return ATan2(2*(W*Z+X*Y), 1-2*(YSquared+Z**2)), Pitch, ATan2(2*(W*X+Y*Z), 1-2*(YSquared+X**2));
	}
}

class ZMatrix{
	private
	int Columns,
		Rows;

	private
	Array<double> Values;

	static
	ZMatrix Create(int Rows, int Columns)
	{return new("ZMatrix").Init(Rows, Columns, false);}

	static
	ZMatrix Identity(int Size)
	{return new("ZMatrix").Init(Size, Size, true);}

	private
	ZMatrix Init(int Rows, int Columns, bool Identity){
		if(Identity)
			if(Columns!=Rows && Columns!=0)ZManager.Error("Attempted to create a non-square identity matrix", ERR_FATAL);
			else Columns=Rows;
		if(Rows<=0 || Columns<=0)
			ZManager.Error("Attempted to create a non-positively-sized matrix", ERR_FATAL);
		self.Rows=Rows;
		self.Columns=Columns;
		Values.Resize(Rows*Columns);
		for(int i=0; i<Values.Size(); i++)Values[i]=Identity?1:0;
		return self;
	}

	double Set(int Value, int Row, int Column)
	{return Values[Row*Columns+Column]=Value;}

	double Get(int Row, int Column) const
	{return Values[Row*Columns+Column];}

	int GetRows() const
	{return Rows;}

	int GetColumns() const
	{return Columns;}

	ZMatrix Add(ZMatrix Other) const{
		if(Rows!=Other.Rows || Columns!=Other.Columns)ZManager.Error("Attempted to add differently-sized matrices", ERR_FATAL);
		ZMatrix Result=ZMatrix.Create(Rows, Columns);
		for(int Row=0; Row<Rows; Row++)
			for(int Column=0; Column<Columns; Column++)
				Result.Set(Row, Column, Get(Row, Column)+Other.Get(Row, Column));
		return Result;
	}

	ZMatrix SMultiply(double Multiplier) const{
		ZMatrix Result=ZMatrix.Create(Rows, Columns);
		for(int Row=0; Row<Rows; Row++)
			for(int Column=0; Column<Columns; Column++)
				Result.Set(Row, Column, Get(Row, Column)*Multiplier);
		return Result;
	}

	ZMatrix MMultiply(ZMatrix Other) const{
		if(Columns!=Other.Rows)ZManager.Error("Attempted to multiply incorrectly-sized matrices", ERR_FATAL);
		ZMatrix Result=ZMatrix.Create(Rows, Other.Columns);
		for(int Row=0; Row<Rows; Row++)
			for(int Column=0; Column<Columns; Column++){
				double Value;
				for(int i=0; i<Columns; i++)
					Value+=Get(Row, i)*Other.Get(i, Column);
				Result.Set(Row, Column, Value);
			}
		return Result;
	}
}

class ZLeftInterpolator{
	protected
	int CurrentValue;

	static
	ZLeftInterpolator Create(int DesiredValue){
		ZLeftInterpolator Interpolator = new("ZLeftInterpolator");
		Interpolator.Reset(DesiredValue);
		return Interpolator;
	}

	void Reset(int DesiredValue)
	{CurrentValue=DesiredValue;}

	//This must be called peroiodically in the status bar's Tick function.
	//Do not call this in the Draw function because that may skip some frames!
	void Update(int DesiredValue){
		for(int i=9; i>=0; i--){
			int Place=10**i;
			if(CurrentValue/Place>DesiredValue/Place){
				CurrentValue-=Place;
				break;
			}else if(CurrentValue/Place<DesiredValue/Place){
				CurrentValue+=Place;
				break;
			}
		}
	}

	//This must be called in the draw function to retrieve the value for output.
	int GetValue() const
	{return CurrentValue;}
}