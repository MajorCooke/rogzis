class ZMatrix{
    private
    uint Columns,
         Rows;

    private
    Array<double> Values;

    static
    ZMatrix Create(uint Rows, uint Columns)
    {return new("ZMatrix").Init(Rows, Columns, false);}

    static
    ZMatrix Identity(uint Size)
    {return new("ZMatrix").Init(Size, Size, true);}

    private
    ZMatrix Init(uint Rows, uint Columns, bool Ones){
        if(Rows<=0 || Columns<=0)
            ZManager.Error("Attempted to create a non-positively-sized matrix", ERR_FATAL);
        self.Rows=Rows;
        self.Columns=Columns;
        Values.Resize(Rows*Columns);
        for(int i=0; i<Values.Size(); i++)Values[i]=Ones;
        return self;
    }

    static
    ZMatrix Randomized(uint Rows, uint Columns, int Seed, double Floor=-1, double Ceiling=1)
    {return new("ZMatrix").Init(Rows, Columns, true).Noise(Seed, Floor, Ceiling);}

    void Set(uint Row, uint Column, double Value)
    {Values[Row*Columns+Column]=Value;}

    void V2Set(uint Row, uint Column, Vector2 Point, bool Row=true){
        if(Row){
            Set(Row, Column*2, Point.X);
            Set(Row, Column*2+1, Point.Y);
        }else{
            Set(Row*2, Column, Point.X);
            Set(Row*2+1, Column, Point.Y);
        }
    }

    double Get(uint Row, uint Column=0) const
    {return Values[Row*Columns+Column];}

    Vector2 V2Get(uint Row, uint Column=0, bool Row=true) const{
        if(Row)
            return (Get(Row, Column*2), Get(Row, Column*2+1));
        return (Get(Row*2, Column), Get(Row*2+1, Column));
    }

    double RowSum(uint Row) const{
        double Total=0;
        for(int i=0; i<Columns; i++)
            Total+=Get(Row, i);
        return Total;
    }

    double ColSum(uint Column) const{
        double Total=0;
        for(int i=0; i<Rows; i++)
            Total+=Get(i, Column);
        return Total;
    }

    uint Height() const
    {return Rows;}

    uint Width() const
    {return Columns;}

    ZMatrix Add(ZMatrix Other) const{
        if(Rows!=Other.Rows || Columns!=Other.Columns)ZManager.Error("Attempted to add differently-sized matrices", ERR_FATAL);
        ZMatrix Result=ZMatrix.Create(Rows, Columns);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                Result.Set(Row, Column, Get(Row, Column)+Other.Get(Row, Column));
        return Result;
    }

    ZMatrix Subtract(ZMatrix Other) const{
        if(Rows!=Other.Rows || Columns!=Other.Columns)ZManager.Error("Attempted to add differently-sized matrices", ERR_FATAL);
        ZMatrix Result=ZMatrix.Create(Rows, Columns);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                Result.Set(Row, Column, Get(Row, Column)-Other.Get(Row, Column));
        return Result;
    }

    ZMatrix Multiply(ZMatrix Other){
        if(Rows!=Other.Rows || Columns!=Other.Columns)ZManager.Error("Attempted to multiply differently-sized matrices", ERR_FATAL);
        ZMatrix Result=ZMatrix.Create(Rows, Columns);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                Result.Set(Row, Column, Get(Row, Column)*Other.Get(Row, Column));
        return Result;
    }

    ZMatrix SMultiply(double Multiplier) const{
        ZMatrix Result=ZMatrix.Create(Rows, Columns);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                Result.Set(Row, Column, Get(Row, Column)*Multiplier);
        return Result;
    }

    ZMatrix MMultiply(ZMatrix Other) const{
        if(Columns!=Other.Rows)ZManager.Error("Attempted to multiply incorrectly-sized matrices", ERR_FATAL);
        ZMatrix Result=ZMatrix.Create(Rows, Other.Columns);
        for(int Row=0; Row<Result.Rows; Row++)
            for(int Column=0; Column<Result.Columns; Column++){
                double Value=0;
                for(int i=0; i<Columns; i++)
                    Value+=Get(Row, i)*Other.Get(i, Column);
                Result.Set(Row, Column, Value);
            }
        return Result;
    }

    ZMatrix SMin(double Min, double Min2=int.max){
        ZMatrix Result=Create(Rows, Columns);
        for(int Row=0; Row<Result.Rows; Row++)
            for(int Column=0; Column<Result.Columns; Column++)
                Result.Set(Row, Column, Min(Get(Row, Column), Min, Min2));
        return Result;
    }

    ZMatrix MMin(ZMatrix Min, ZMatrix Min2=null){
        if(Rows!=Min.Rows || Columns!=Min.Columns || (Min2 && (Rows!=Min2.Rows || Columns!=Min2.Columns)))ZManager.Error("Attempted to min differently-sized matrices", ERR_FATAL);
        ZMatrix Result=Create(Rows, Columns);
        for(int Row=0; Row<Result.Rows; Row++)
            for(int Column=0; Column<Result.Columns; Column++)
                Result.Set(Row, Column, Min(Get(Row, Column), Min.Get(Row, Column), (Min2)?Min2.Get(Row, Column):int.max));
        return Result;
    }

    ZMatrix SMax(double Max, double Max2=int.min){
        ZMatrix Result=Create(Rows, Columns);
        for(int Row=0; Row<Result.Rows; Row++)
            for(int Column=0; Column<Result.Columns; Column++)
                Result.Set(Row, Column, Max(Get(Row, Column), Max, Max2));
        return Result;
    }

    ZMatrix MMax(ZMatrix Max, ZMatrix Max2=null){
        if(Rows!=Max.Rows || Columns!=Max.Columns || (Max2 && (Rows!=Max2.Rows || Columns!=Max2.Columns)))ZManager.Error("Attempted to min differently-sized matrices", ERR_FATAL);
        ZMatrix Result=Create(Rows, Columns);
        for(int Row=0; Row<Result.Rows; Row++)
            for(int Column=0; Column<Result.Columns; Column++)
                Result.Set(Row, Column, Max(Get(Row, Column), Max.Get(Row, Column), (Max2)?Max2.Get(Row, Column):int.min));
        return Result;
    }

    ZMatrix SClamp(double Min, double Max){
        ZMatrix Result=Create(Rows, Columns);
        for(int Row=0; Row<Result.Rows; Row++)
            for(int Column=0; Column<Result.Columns; Column++)
                Result.Set(Row, Column, Clamp(Get(Row, Column), Min, Max));
        return Result;
    }

    ZMatrix MClamp(ZMatrix Min, ZMatrix Max){
        if(Rows!=Min.Rows || Columns!=Min.Columns || Rows!=Max.Rows || Columns!=Max.Columns)ZManager.Error("Attempted to min differently-sized matrices", ERR_FATAL);
        ZMatrix Result=Create(Rows, Columns);
        for(int Row=0; Row<Result.Rows; Row++)
            for(int Column=0; Column<Result.Columns; Column++)
                Result.Set(Row, Column, Clamp(Get(Row, Column), Min.Get(Row, Column), Max.Get(Row, Column)));
        return Result;
    }

    ZMatrix Transpose() const{
        ZMatrix Result=Create(Columns, Rows);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                Result.Set(Column, Row, Get(Row, Column));
        return Result;
    }

    ZMatrix Clone() const
    {return SMultiply(1);}

    ZMatrix Mutate(int Seed, double Floor=0, double Ceiling=1, double MaxChange=1, double MutationRate=.1) const{
        ZMatrix Result=Randomized(Rows, Columns, Seed).SMultiply(MaxChange),
                Chance=Randomized(Rows, Columns, Seed, 0).SMax(MutationRate);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                if(Chance.Get(Row, Column)>MutationRate)
                    Result.Set(Row, Column, 0);
        return Add(Result).SClamp(Floor, Ceiling);
    }

    ZMatrix Noise(int Seed=int('NoiseyBoi'), double Floor=-1, double Ceiling=1) const{
        SetRandomSeed[NoiseyBoi](Seed);
        ZMatrix Result=ZMatrix.Create(Rows, Columns);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                Result.Set(Row, Column, Get(Row, Column)*FRandom[NoiseyBoi](Floor, Ceiling));
        return Result;
    }

    ZMatrix SmoothNoise(int Octave) const{
        ZMatrix Result=Create(Rows, Columns);
        int Period=2**Octave;
        double Frequency=1/Period;
        for(int i=0; i<Rows; i++){
            int i1=i/Period*Period,
                i2=(i1+Period)%Rows;
            float HBlend=(i-i1)*Frequency;
            for(int j=0; j<Columns; j++){
                int j1=(j/Period)*Period,
                    j2=(j1+Period)%Columns;
                Result.Set(i, j, ZCalc.Lerp((j-j1)*Frequency, ZCalc.Lerp(HBlend, Get(i1, j1), Get(i2, j1)), ZCalc.Lerp(HBlend, Get(i1, j2), Get(i2, j2))));
            }
        }
        return Result;
    }
}