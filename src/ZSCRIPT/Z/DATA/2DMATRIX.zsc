class ZMatrix2{
    private
    uint Columns,
         Rows;

    Array<double> Values;

    static
    ZMatrix2 Create(uint Rows, uint Columns=1)
    {return new('ZMatrix2').Init(Rows, Columns, false);}

    static
    ZMatrix2 Identity(uint Size)
    {return new('ZMatrix2').Init(Size, Size, true);}

    private
    ZMatrix2 Init(uint Rows, uint Columns, bool Ones){
        if(Rows<=0 || Columns<=0)
            ZManager.Error("Attempted to create a non-positively-sized matrix", ERR_FATAL);
        self.Rows=Rows;
        self.Columns=Columns;
        for(int i=0; i<Rows*Columns; i++)Values.Push(Ones);
        return self;
    }

    static
    ZMatrix2 Randomized(uint Rows, uint Columns, int Seed, double Floor=-1, double Ceiling=1)
    {return new('ZMatrix2').Init(Rows, Columns, true).Noise(Seed, Floor, Ceiling);}

    void Set(uint Row, uint Column, double Value)
    {Values[Row*Columns+Column]=Value;}

    void V2Set(uint Row, uint Column, Vector2 Point, bool Row=true){
        if(Row){
            Set(Row, Column*2, Point.X);
            Set(Row, Column*2+1, Point.Y);
        }else{
            Set(Row*2, Column, Point.X);
            Set(Row*2+1, Column, Point.Y);
        }
    }

    //////////
    // Info //
    //////////
    double Get(uint Row, uint Column=0) const
    {return Values[Row*Columns+Column];}

    Vector2 V2Get(uint Row, uint Column=0, bool Row=true) const{
        if(Row)
            return (Get(Row, Column*2), Get(Row, Column*2+1));
        return (Get(Row*2, Column), Get(Row*2+1, Column));
    }

    ZMatrix2 Row(uint Index) const{
        ZMatrix2 Result=Create(1, Columns);
        for(int i=0; i<Columns; i++)
            Result.Set(0, i, Get(Index, i));
        return Result;
    }

    ZMatrix2 AsRow() const{
        ZMatrix2 Result=Create(Values.Size());
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i];
        return Result;
    }

    uint Height() const
    {return Rows;}

    ZMatrix2 Col(uint Column) const{
        ZMatrix2 Result=Create(Rows);
        for(int i=0; i<Rows; i++)
            Result.Set(i, 0, Get(i, Column));
        return Result;
    }

    ZMatrix2 AsCol() const{
        ZMatrix2 Result=Create(1, Values.Size());
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i];
        return Result;
    }

    uint Width() const
    {return Columns;}

    // All Values

    double ASum() const{
        double Total=0;
        for(int i=0; i<Values.Size(); i++)
            Total+=Values[i];
        return Total;
    }

    double AMin() const{
        double Min=Values[0];
        for(int i=1; i<Values.Size(); i++)
            Min=Min(Min, Values[i]);
        return Min;
    }

    double AMax() const{
        double Max=Values[0];
        for(int i=1; i<Values.Size(); i++)
            Max=Max(Max, Values[i]);
        return Max;
    }

    double ARange() const
    {return AMax()-AMin();}

    double AAMean() const
    {return ASum()/Values.Size();}

    double AGMean() const{
        double Total=1;
        for(int i=0; i<Values.Size(); i++)
            Total*=Values[i];
        return Total**(1/Values.Size());
    }

    double AHMean() const
    {return Values.Size()/SExponent(-1).ASum();}

    double AVariance(bool Statistic=true) const{
        double Total=0,
               Mean=AAMean();
        for(int i=0; i<Values.Size(); i++)
            Total+=(Values[i]-Mean)**2;
        return Total/(Values.Size()-Statistic);
    }

    double AStdDev(bool Statistic=true) const
    {return Sqrt(AVariance());}

    // Per Row/Column

    ZMatrix2 TSum(bool AsRow=false, bool ForRows=false) const{
        int Size=(ForRows)?Rows:Columns;
        ZMatrix2 Result=Create((AsRow)?1:Size, (!AsRow)?1:Size);
        for(int i=0; i<Size; i++){
            if(ForRows)
                Result.Values[i]=Row(i).ASum();
            else Result.Values[i]=Col(i).ASum();
        }
        return Result;
    }

    ZMatrix2 TMin(bool AsRow=false, bool ForRows=false) const{
        int Size=(ForRows)?Rows:Columns;
        ZMatrix2 Result=Create((AsRow)?1:Size, (!AsRow)?1:Size);
        for(int i=0; i<Size; i++){
            if(ForRows)
                Result.Values[i]=Row(i).AMin();
            else Result.Values[i]=Col(i).AMin();
        }
        return Result;
    }

    ZMatrix2 TMax(bool AsRow=false, bool ForRows=false) const{
        int Size=(ForRows)?Rows:Columns;
        ZMatrix2 Result=Create((AsRow)?1:Size, (!AsRow)?1:Size);
        for(int i=0; i<Size; i++){
            if(ForRows)
                Result.Values[i]=Row(i).AMax();
            else Result.Values[i]=Col(i).AMax();
        }
        return Result;
    }

    ZMatrix2 TRange(bool AsRow=false, bool ForRows=false) const{
        return TMax(AsRow, ForRows).Subtract(TMin(AsRow, ForRows));
    }

    ZMatrix2 TAMean(bool AsRow=false, bool ForRows=false) const{
        int Size=(ForRows)?Rows:Columns;
        ZMatrix2 Result=Create((AsRow)?1:Size, (!AsRow)?1:Size);
        for(int i=0; i<Size; i++){
            if(ForRows)
                Result.Values[i]=Row(i).AAMean();
            else Result.Values[i]=Col(i).AAMean();
        }
        return Result;
    }

    ZMatrix2 TGMean(bool AsRow=false, bool ForRows=false) const{
        int Size=(ForRows)?Rows:Columns;
        ZMatrix2 Result=Create((AsRow)?1:Size, (!AsRow)?1:Size);
        for(int i=0; i<Size; i++){
            if(ForRows)
                Result.Values[i]=Row(i).AGMean();
            else Result.Values[i]=Col(i).AGMean();
        }
        return Result;
    }

    ZMatrix2 THMean(bool AsRow=false, bool ForRows=false) const{
        int Size=(ForRows)?Rows:Columns;
        ZMatrix2 Result=Create((AsRow)?1:Size, (!AsRow)?1:Size);
        for(int i=0; i<Size; i++){
            if(ForRows)
                Result.Values[i]=Row(i).AHMean();
            else Result.Values[i]=Col(i).AHMean();
        }
        return Result;
    }

    ZMatrix2 TVariance(bool Statistic=true, bool AsRow=false, bool ForRows=false) const{
        int Size=(ForRows)?Rows:Columns;
        ZMatrix2 Result=Create((AsRow)?1:Size, (!AsRow)?1:Size);
        for(int i=0; i<Size; i++){
            if(ForRows)
                Result.Values[i]=Row(i).AVariance();
            else Result.Values[i]=Col(i).AVariance();
        }
        return Result;
    }

    ZMatrix2 TStdDev(bool Statistic=true, bool AsRow=false, bool ForRows=false) const
    {return TVariance(Statistic, AsRow, ForRows).SExponent(.5);}

    ///////////////////
    // Manipulations //
    ///////////////////
    ZMatrix2 Add(ZMatrix2 Other) const{
        if(Rows!=Other.Rows || Columns!=Other.Columns)
            ZManager.Error("Attempted to add differently-sized matrices", ERR_FATAL);
        ZMatrix2 Result=ZMatrix2.Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i]+Other.Values[i];
        return Result;
    }

    ZMatrix2 Subtract(ZMatrix2 Other) const{
        if(Rows!=Other.Rows || Columns!=Other.Columns)
            ZManager.Error("Attempted to subtract differently-sized matrices", ERR_FATAL);
        ZMatrix2 Result=ZMatrix2.Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i]-Other.Values[i];
        return Result;
        return Add(Other.SMultiply(-1));
    }

    ZMatrix2 Multiply(ZMatrix2 Other){
        if(Rows!=Other.Rows || Columns!=Other.Columns)
            ZManager.Error("Attempted to multiply differently-sized matrices", ERR_FATAL);
        ZMatrix2 Result=ZMatrix2.Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i]*Other.Values[i];
        return Result;
    }

    ZMatrix2 Divide(ZMatrix2 Other){
        if(Rows!=Other.Rows || Columns!=Other.Columns)
            ZManager.Error("Attempted to multiply differently-sized matrices", ERR_FATAL);
        ZMatrix2 Result=ZMatrix2.Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i]/Other.Values[i];
        return Result;
    }

    ZMatrix2 SMultiply(double Multiplier) const{
        ZMatrix2 Result=ZMatrix2.Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i]*Multiplier;
        return Result;
    }

    ZMatrix2 SDivide(double Divisor) const{
        ZMatrix2 Result=ZMatrix2.Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i]/Divisor;
        return Result;
    }

    ZMatrix2 SExponent(double Degree){
        ZMatrix2 Result=ZMatrix2.Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Values[i]**Degree;
        return Result;
    }

    ZMatrix2 MMultiply(ZMatrix2 Other) const{
        if(Columns!=Other.Rows)
            ZManager.Error("Attempted to multiply incorrectly-sized matrices", ERR_FATAL);
        ZMatrix2 Result=ZMatrix2.Create(Rows, Other.Columns);
        for(int Row=0; Row<Result.Rows; Row++)
            for(int Column=0; Column<Result.Columns; Column++){
                double Value=0;
                for(int i=0; i<Columns; i++)
                    Value+=Get(Row, i)*Other.Get(i, Column);
                Result.Set(Row, Column, Value);
            }
        return Result;
    }

    ZMatrix2 SMin(double Min, double Min2=int.max) const{
        ZMatrix2 Result=Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Min(Values[i], Min, Min2);
        return Result;
    }

    ZMatrix2 MMin(ZMatrix2 Min, ZMatrix2 Min2=null) const{
        if(Rows!=Min.Rows || Columns!=Min.Columns || (Min2 && (Rows!=Min2.Rows || Columns!=Min2.Columns)))
            ZManager.Error("Attempted to min differently-sized matrices", ERR_FATAL);
        ZMatrix2 Result=Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Min(Values[i], Min.Values[i], (Min2)?Min2.Values[i]:int.max);
        return Result;
    }

    ZMatrix2 SMax(double Max, double Max2=int.min) const{
        ZMatrix2 Result=Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Max(Values[i], Max, Max2);
        return Result;
    }

    ZMatrix2 MMax(ZMatrix2 Max, ZMatrix2 Max2=null) const{
        if(Rows!=Max.Rows || Columns!=Max.Columns || (Max2 && (Rows!=Max2.Rows || Columns!=Max2.Columns)))
            ZManager.Error("Attempted to min differently-sized matrices", ERR_FATAL);
        ZMatrix2 Result=Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Max(Values[i], Max.Values[i], (Max2)?Max2.Values[i]:int.min);
        return Result;
    }

    ZMatrix2 SClamp(double Min, double Max) const{
        ZMatrix2 Result=Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Clamp(Values[i], Min, Max);
        return Result;
    }

    ZMatrix2 MClamp(ZMatrix2 Min, ZMatrix2 Max) const{
        if(Rows!=Min.Rows || Columns!=Min.Columns || Rows!=Max.Rows || Columns!=Max.Columns)
            ZManager.Error("Attempted to min differently-sized matrices", ERR_FATAL);
        ZMatrix2 Result=Create(Rows, Columns);
        for(int i=0; i<Values.Size(); i++)
            Result.Values[i]=Clamp(Values[i], Min.Values[i], Max.Values[i]);
        return Result;
    }

    ZMatrix2 Transpose() const{
        ZMatrix2 Result=Create(Columns, Rows);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                Result.Set(Column, Row, Get(Row, Column));
        return Result;
    }

    ZMatrix2 Clone() const{
        ZMatrix2 Result=Create(Rows, Columns);
        Result.Values.Copy(Values);
        return Result;
    }

    ZMatrix2 Mutate(int Seed, double Floor=0, double Ceiling=1, double MaxChange=1, double MutationRate=.1) const{
        ZMatrix2 Result=Randomized(Rows, Columns, Seed).SMultiply(MaxChange),
                Chance=Randomized(Values.Size(), Seed+1, 0).SMax(MutationRate);
        for(int i=0; i<Values.Size(); i++)
            if(Chance.Values[i]<=MutationRate)
                Result.Values[i]=Clamp(Values[i]+Result.Values[i], Floor, Ceiling);
            else Result.Values[i]=Values[i];
        return Result;
    }

    ZMatrix2 Append(ZMatrix2 Other){
        ZMatrix2 Result=Create(Rows+ZCalc.Round(Other.Values.Size()/double(Columns)), Columns);
        Result.Values.Copy(Values);
        for(int i=0; i<Other.Values.Size(); i++)
            Result.Values[Values.Size()+i]=Other.Values[i];
        return Result;
    }

    ZMatrix2 Noise(int Seed=int('NoiseyBoi'), double Floor=-1, double Ceiling=1) const{
        SetRandomSeed[NoiseyBoi](Seed);
        ZMatrix2 Result=ZMatrix2.Create(Rows, Columns);
        for(int Row=0; Row<Rows; Row++)
            for(int Column=0; Column<Columns; Column++)
                Result.Set(Row, Column, Get(Row, Column)*FRandom[NoiseyBoi](Floor, Ceiling));
        return Result;
    }

    ZMatrix2 SmoothNoise(int Octave) const{
        ZMatrix2 Result=Create(Rows, Columns);
        int Period=2**Octave;
        double Frequency=1/Period;
        for(int i=0; i<Rows; i++){
            int i1=i/Period*Period,
                i2=(i1+Period)%Rows;
            float HBlend=(i-i1)*Frequency;
            for(int j=0; j<Columns; j++){
                int j1=(j/Period)*Period,
                    j2=(j1+Period)%Columns;
                Result.Set(i, j, ZCalc.Lerp((j-j1)*Frequency, ZCalc.Lerp(HBlend, Get(i1, j1), Get(i2, j1)), ZCalc.Lerp(HBlend, Get(i1, j2), Get(i2, j2))));
            }
        }
        return Result;
    }
}