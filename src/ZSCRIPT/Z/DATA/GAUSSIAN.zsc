class ZGaussian{
    private
    bool PreGenerated;

    private
    int PreGen;

    private
    double Mean,
           StdDev;

    private
    Array<double> CachedValues;

    static
    ZGaussian Create(double Mean=0, double StdDev=1, int Seed=int('GauseyBoi'))
    {return new('ZGaussian').Init(Mean, StdDev, Seed);}

    private
    ZGaussian Init(double Mean, double StdDev, int Seed=0){
        if(!Seed)
            Seed=ZManager.RandSeed();
        self.Mean=Mean;
        self.StdDev=StdDev;
        SetRandomSeed[GauseyBoi](Seed);
        return self;
    }

    void Simulate(int Amount){
        for(int i=0; i<Amount; i++)
            CachedValues.Push(Generate());
    }

    double Generate(){
        PreGenerated=!PreGenerated;
        if(!PreGenerated)
            return PreGen*StdDev+Mean;
        else{
            double u1, u2;
            do{
                u1=FRandom[GauseyBoi](0, 1);
                u2=FRandom[GauseyBoi](0, 1);
            }while(u1<=double.epsilon);
            double Gen=Sqrt(-2*Log(u1))*Cos(2*ZCalc.PI*u2);
            PreGen=Sqrt(-2*Log(u1))*Sin(2*ZCalc.PI*u2);
            return Gen*StdDev+Mean;
        }
    }

    double Get() const
    {return CachedValues[Random(0, CachedValues.Size())];}

    double Normalize(double Value) const
    {return (Value-Mean)/StdDev;}

    void Clear()
    {CachedValues.Clear();}

    ZMatrix2 Matrix(bool Row=false) const{
        ZMatrix2 Result=ZMatrix2.Create((Row)?1:CachedValues.Size(), (!Row)?1:CachedValues.Size());
        Result.Values.Copy(CachedValues);
        return Result;
    }
}