class ZGaussian{
    private
    bool PreGenerated;

    private
    int PreGen;

    private
    double __Mean__,
           __StdDev__;

    private
    Array<double> CachedValues;

    static
    ZGaussian Create(double Mean=0, double StdDev=1, int Seed=0){
        ZGaussian Result=new('ZGaussian');
        if(!Seed)
            Seed=ZManager.RandSeed();
        SetRandomSeed[GauseyBoi](Seed);
        Result.__Mean__=Mean;
        Result.__StdDev__=StdDev;
        return Result;
    }

    void Simulate(int Amount){
        for(int i=0; i<Amount; i++)
            CachedValues.Push(Generate());
    }

    double Mean() const
    {return __Mean__;}

    double StdDev() const
    {return __StdDev__;}

    double Generate(){
        PreGenerated=!PreGenerated;
        if(!PreGenerated)
            return PreGen*__StdDev__+__Mean__;
        else{
            double u1, u2;
            do{
                u1=FRandom[GauseyBoi](0, 1);
                u2=FRandom[GauseyBoi](0, 1);
            }while(u1<=double.epsilon);
            double Gen=Sqrt(-2*Log(u1))*Cos(2*ZCalc.PI*u2);
            PreGen=Sqrt(-2*Log(u1))*Sin(2*ZCalc.PI*u2);
            return Gen*__StdDev__+__Mean__;
        }
    }

    double Get(int Index=-1) const
    {return CachedValues[(Index<0)?Random(0, CachedValues.Size()-1):Index];}

    double Normalize(double Value) const
    {return (Value-__Mean__)/__StdDev__;}

    void Clear()
    {CachedValues.Clear();}

    ZVector ToV() const{
        ZVector Result=ZVector.Create(CachedValues.Size());
        Result.Values.Copy(CachedValues);
        return Result;
    }
}