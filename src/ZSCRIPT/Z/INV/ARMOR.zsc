enum ArmorInfo{
	//Armor Slots	-	Only One
	AMR_HEAD		=	1<<0,
	AMR_TORSO		=	1<<1,
	AMR_HANDS		=	1<<2,
	AMR_LEGS		=	1<<3,
	AMR_FEET		=	1<<4,

	//Armor Types	-	Multiple
	AMR_PLATE		=	1<<5,
	AMR_MAGNET		=	1<<6,	//Also provides abilties
	AMR_SHIELD		=	1<<7,
	AMR_LIGHT		=	1<<8,

	//Attributes	-	Multiple
	AMR_ENERGY		=	1<<9,	//Needed for AMR_MAGNET, AMR_PLASMA and AMR_LIGHT
	AMR_SEALED		=	1<<10,	//Not needed for AMR_LIGHT
	AMR_THRUST		=	1<<11,
	AMR_JETPACK		=	1<<12,	//Evolution of AMR_THRUST
	AMR_MAGNIFY		=	1<<13,	//Binoculars
	AMR_MOWNPOWER	=	1<<14,	//Separates armor systems' energy
	AMR_SOWNPOWER	=	1<<15,
	AMR_LOWNPOWER	=	1<<16,
};

struct ArmorStats{
	int /////////////////////
		// Defensive Stats //
		/////////////////////
		//Energy
		Energy,
		EnergyRechargeRate,
		
		//Armor Plating
		PlateAbsorption,
		
		//Magnetic Repulsion
		Magnet,
		MagnetRechargeRate,
		
		//Plasma Shield
		Shield,
		ShieldDivider,
		ShieldRechargeRate,
		
		//Hard Light Construct
		Light,
		
		////////////////////
		// Abilties Stats //
		////////////////////
		ThrustPower,
		JetpackPower;
}

class Armors:Registry{
	bool Add(ArmorPiece ArmorPiece)
	{return ArmorPiece && super.Add(ArmorPiece);}
	
	ArmorPiece Get(Name Name) const
	{return ArmorPiece(super.Get(Name));}
	
	ArmorPiece GetRand() const
	{return ArmorPiece(super.GetRand());}
}

class ArmorPiece:Item play{
	protected
	int /////////////////////
		// Defensive Stats //
		/////////////////////
		//Energy
		Energy,
		MaxEnergy,
		EnergyRechargeRate,
		
		//Armor Plating
		PlateAbsorption,
		
		//Magnetic Repulsion
		Magnet,
		MaxMagnet,
		MagnetRechargeRate,
		
		//Plasma Shield
		Shield,
		MaxShield,
		ShieldDivider,
		ShieldRechargeRate,
		
		//Hard Light Construct
		Light,
		MaxLight,
		
		/////////////////////
		// Abilities Stats //
		/////////////////////
		ThrustPower,
		JetpackPower;

	protected
	ArmorInfo Info;

	static
	ArmorPiece Create(String Name, String Description, in out ArmorStats Stats, ArmorInfo Info=0, int Price=0, int Durability=0, int Width=-1, int Height=-1)
	{return new("ArmorPiece").Init(Name, Description, Stats, Info, Price, Durability, Width, Height);}
	
	protected
	ArmorPiece Init(String Name, String Description, in out ArmorStats Stats, ArmorInfo Info, int Price, int Durability, int Width, int Height){
		//Armor Stats
		if(Info & AMR_PLATE)
			PlateAbsorption=Stats.PlateAbsorption;
		if(Info & AMR_ENERGY){
			Energy=MaxEnergy=Stats.Energy;
			EnergyRechargeRate=Stats.EnergyRechargeRate;
			if(Info & (AMR_MAGNET | AMR_MOWNPOWER)){
				Magnet=MaxMagnet=Stats.Magnet;
				MagnetRechargeRate=Stats.MagnetRechargeRate;
			}
			if(Info & (AMR_SHIELD | AMR_SOWNPOWER)){
				Shield=MaxShield=Stats.Shield;
				ShieldDivider=Stats.ShieldDivider;
				ShieldRechargeRate=Stats.ShieldRechargeRate;
			}
			if(Info & (AMR_LIGHT | AMR_LOWNPOWER))
				Light=MaxLight=Stats.Light;
			if(Info & AMR_THRUST)
				ThrustPower=Stats.ThrustPower;
			if(Info & AMR_JETPACK)
				JetpackPower=Stats.JetpackPower;
		}
		//Item Initialization
		if(Width==-1)
			if(Info & AMR_HEAD)
				Width=1;
			else
				Width=2;
		if(Height==-1)
			if(Info & AMR_HEAD)
				Height=1;
			else if((Info & AMR_HANDS) || (Info & AMR_FEET))
				Height=1;
			else
				Height=2;
		self.Info=Info;
		return ArmorPiece(super.Init(Name, Description, Price, Durability, Width, Height));
	}
	
	virtual
	int ModifyDamage(int Damage, Name DamageType, in out ZPlayer Player){
		ZDamageType ZDamageType=ZManager.DamageType(DamageType);
		int Dam;
		double TempDamage=Damage;
		//Powered Armor
		if(Info & AMR_ENERGY){
			//Magnetic Repulsion
			if(Info & AMR_MAGNET)
				if(Info & AMR_MOWNPOWER){
					if((Dam=TempDamage*ZDamageType.Factor(AMR_MAGNET))>0)
						if(ceil(Dam)<=Magnet){
							Magnet-=Dam;
							return 0;
						}else{
							TempDamage-=floor(Magnet/ZDamageType.Factor(AMR_MAGNET));
							Magnet=0;
						}
					else if(Dam<0){
						Magnet=clamp(Magnet-ceil(Dam), 0, MaxMagnet);
						return 0;
					}
				}else{
					if((Dam=TempDamage*ZDamageType.Factor(AMR_MAGNET))>0)
						if(ceil(Dam)<=Energy){
							Energy-=Dam;
							return 0;
						}else{
							TempDamage-=floor(Energy/ZDamageType.Factor(AMR_MAGNET));
							Energy=0;
						}
					else if(Dam<0){
						Energy=clamp(Energy-ceil(Dam), 0, MaxEnergy);
						return 0;
					}
				}

			//Hard Light Construct
			if(Info & AMR_LIGHT)
				if(Info & AMR_LOWNPOWER){
					if((Dam=TempDamage*ZDamageType.Factor(AMR_LIGHT))>0)
						if(ceil(Dam)<=Light){
							Light-=Dam;
							return 0;
						}else{
							TempDamage-=floor(Light/ZDamageType.Factor(AMR_LIGHT));
							Light=0;
						}
					else if(Dam<0){
						Light=clamp(Light-ceil(Dam), 0, MaxLight);
						return 0;
					}
				}else{
					if((Dam=TempDamage*ZDamageType.Factor(AMR_LIGHT))>0)
						if(ceil(Dam)<=Energy){
							Energy-=Dam;
							return 0;
						}else{
							TempDamage-=floor(Energy/ZDamageType.Factor(AMR_LIGHT));
							Energy=0;
						}
					else if(Dam<0){
						Energy=clamp(Energy-ceil(Dam), 0, MaxEnergy);
						return 0;
					}
				}

			//Plasma Shield
			if(Info & AMR_SHIELD)
				if(Info & AMR_SOWNPOWER){
					if((Dam=TempDamage*ZDamageType.Factor(AMR_SHIELD))>0)
						if(ceil(Dam)<=Shield){
							Shield-=Dam;
							return 0;
						}else{
							TempDamage-=floor(Shield/ZDamageType.Factor(AMR_SHIELD));
							Shield=0;
						}
					else if(Dam<0){
						Shield=clamp(Shield-ceil(Dam), 0, MaxShield);
						return 0;
					}
				}else{
					if((Dam=TempDamage*ZDamageType.Factor(AMR_SHIELD))>0)
						if(ceil(Dam)<=Energy){
							Energy-=Dam;
							return 0;
						}else{
							TempDamage-=floor(Energy/ZDamageType.Factor(AMR_SHIELD));
							Energy=0;
						}
					else if(Dam<0){
						Energy=clamp(Energy-ceil(Dam), 0, MaxEnergy);
						return 0;
					}
				}
		}

		//Armor Plating
		if((Info & AMR_PLATE) && ((Dam=TempDamage*ZDamageType.Factor(AMR_PLATE))>0)){
			TempDamage*=1-PlateAbsorption*sqrt(clamp(Durability/MaxDurability, 0, 2));
		}
		return ceil(TempDamage);
	}
}