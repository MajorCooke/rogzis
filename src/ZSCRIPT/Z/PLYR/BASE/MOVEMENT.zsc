extend
class ZPlayerBase{
	transient
	bool MidAir,
         CrouchingJump;

    transient
    int DashOppurt,
		DashCountdown,
		CurrentDashButton;

	transient
	double LastVelLength;

	Default{
		MaxStepHeight 18;
	}

    override
	void HandleMovement(){
		let Player = self.Player;
		//[RH] Check for fast turn around
		if((Player.cmd.buttons & ~Player.oldbuttons) & BT_TURN180)
			Player.turnticks = TURN180_TICKS;
		//Handle Movement
		if(ReactionTime)ReactionTime--;
		else{
			UpdateMovementStats();
			MovePlayer();
			CheckMoveUpDown();
            CheckDash();
			CheckJump();
			//Crouch-jumping and reduce crouch step height
			if(Player.OnGround)MaxStepHeight=(Player.CrouchOffset!=0)?14:18;
			else MaxStepHeight=(Player.CrouchOffset!=0 && !CrouchingJump)?4:0;
			//Other Checks
			LowerFriction();
			CheckCollisionDamage();
		}
	}

	virtual
	void UpdateMovementStats(){
		ForwardMove1=MStats.ForwardMove1;
		ForwardMove2=MStats.ForwardMove2;
		SideMove1=MStats.SideMove1;
		SideMove2=MStats.SideMove2;
		ViewBob=MStats.ViewBob;
	}

	override
	void MovePlayer(){
		let Player = self.Player;
		UserCmd cmd = Player.cmd;

		//[RH] 180-degree turn overrides all other yaws
		if (Player.turnticks){
			Player.turnticks--;
			Angle+=(180./TURN180_TICKS);
		}else Angle+=cmd.yaw*(360./65536.);

		Player.OnGround=(Pos.Z<=FloorZ) || bOnMobj || bMBFBouncer || (Player.Cheats & CF_NOCLIP2);

		//killough 10/98:
		//
		//We must apply thrust to the Player and bobbing separately, to avoid
		//anomalies. The thrust applied to bobbing is always the same strength on
		//ice, because the Player still "works just as hard" to Move, while the
		//thrust applied to the Movement varies with 'MoveFactor'.
		if (cmd.forwardMove|cmd.sideMove){
			double MoveFactor,
				   BobFactor,
				   Friction,
				   ForwardMove,
				   SideMove;

			[Friction, MoveFactor]=GetFriction();
			BobFactor=Friction<ORIG_FRICTION?MoveFactor:ORIG_FRICTION_FACTOR;
			if (!Player.OnGround && !bNoGravity && !waterlevel){
				//[RH] allow very limited Movement if not on ground.
                double AirControl=Min(.5*(MStats.ThrustPower/(MStats.ThrustPower+1.)), 1.25);
                MoveFactor*=AirControl;
				BobFactor*=AirControl;
			}

			ForwardMove=cmd.ForwardMove;
			SideMove=cmd.SideMove;
			[ForwardMove, SideMove]=TweakSpeeds(ForwardMove, SideMove);
			ForwardMove*=Speed/256;
			SideMove*=Speed/256;

			//When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && Player.CrouchFactor!=1){
				ForwardMove*=Player.CrouchFactor;
				SideMove*=Player.CrouchFactor;
				BobFactor*=Player.CrouchFactor;
			}

			ForwardMove*=MoveFactor*(35/TICRATE);
			SideMove*=MoveFactor*(35/TICRATE);

			ForwardMove*=CheckSprint();

			if (ForwardMove){
				Bob(Angle, cmd.ForwardMove * BobFactor / 256., true);
				ForwardThrust(ForwardMove, Angle);
			}
			if (SideMove){
				let a=Angle-90;
				Bob(a, cmd.SideMove*BobFactor/256., false);
				Thrust(SideMove, a);
			}

			if ((~Player.Cheats & CF_PREDICTING) && (ForwardMove!=0 || SideMove!=0))PlayRunning();

			if (Player.Cheats & CF_REVERTPLEASE){
				Player.Cheats &= ~CF_REVERTPLEASE;
				Player.Camera=Player.Mo;
			}
		}
	}

    virtual
	double CheckSprint(){
		if(!Player.OnGround)return 1;
		//Sprinting
		ZArmor ChestPiece=MStats.Armor[AMR_TORSO];
		if((ChestPiece.Info & AMR_THRUST) && (~Buttons & BT_BACK) &&
		   (Buttons & BT_SPEED) &&
		   (Buttons & BT_FORWARD) &&
		   (MStats.Energy>MStats.SprintCost) &&
		   (Health>RunHealth)){
			MStats.Recharger=0;
			MStats.Energy-=MStats.SprintCost;
			return MStats.ThrustPower/3.5;
		//Backstep
		}else if((~ChestPiece.Info & AMR_THRUST) && (Buttons & BT_BACK))return SideMove1;
		else return 1;
	}

    virtual
	void CheckDash(){
		//Dash
		if(DashCountdown>0)
			DashCountdown--;
		else{
			if(DashOppurt>0)DashOppurt--;
			else CurrentDashButton=666;
            static const int DashKeys[]={
                BT_FORWARD,
                BT_BACK,
                BT_MOVELEFT,
                BT_MOVERIGHT
            };
			for(int i=Player.OnGround; i<DashKeys.Size(); i++){
				if(((NewButtons & DashKeys[i]) ||
				   ((NewButtons & BT_SPEED) && (Vel.Z!=0 || (~Buttons & BT_FORWARD)) && (Buttons & DashKeys[i]))) &&
				   (MStats.Energy>MStats.DashCost)){
					if((CurrentDashButton==DashKeys[i] && DashOppurt>0) || ((Buttons & ~OldButtons) & BT_SPEED)){
						MStats.Energy-=MStats.DashCost;
						int MidAirBoost=MStats.JumpPower,
							Power=MStats.ThrustPower*ZCalc.Alternate(i);
						if(Vel.Z==0){
							MidAirBoost=0;
							Power*=2;
						}
						Vel.xy+=Power*((i>1)?-SideVector:ViewVector.xy);
						Vel.z+=MidAirBoost;
						DashCountdown=MStats.DashCooldown;
						DashOppurt=0;
					}else{
						CurrentDashButton=DashKeys[i];
						DashOppurt=MStats.DashTimer;
					}
					return;
				}
			}
		}
	}

    override
	void CheckJump(){
		ZArmor Boots=MStats.Armor[AMR_FEET];
		if(DashCountdown>0)DashCountdown--;
		else if(DashOppurt>0)DashOppurt--;
		else CurrentDashButton=666;
		//[RH] check for jump
		if(Buttons & BT_JUMP){
			if((Boots.Info & AMR_THRUST)  && DashCountdown==0 && (~OldButtons & BT_JUMP) && MStats.Energy>MStats.DashCost){
				if(DashOppurt>0 || !Player.OnGround){
					MStats.Energy-=MStats.DashCost;
					Vel.Z+=MStats.ThrustPower;
					DashCountdown=MStats.DashCooldown;
					DashOppurt=0;
				}else if(Player.OnGround)DashOppurt=MStats.DashTimer;
			}
			if(WaterLevel>=2)Vel.Z=4*Speed;
			else if(bNoGravity)Vel.Z=3.;
			else if(Level.IsJumpingAllowed() && Player.OnGround && Player.JumpTics==0){
				double JumpVelZ=MStats.JumpPower*35/TICRATE,
					   JumpFac=0;
				CrouchingJump=Buttons & BT_CROUCH;

				//[BC] If the player has the high jump power, double his jump velocity.
				//(actually, pick the best factors from all active items.)
				for (PowerHighJump p=PowerHighJump(Inv); p!=null; p=PowerHighJump(p.Inv))
					if(p && p.Strength>JumpFac)JumpFac=p.Strength;

				if(JumpFac>0)JumpVelZ*=JumpFac;

				Vel.Z+=JumpVelZ;
				bOnMobj=false;
				Player.JumpTics=-1;
				if(~Player.Cheats & CF_PREDICTING)A_PlaySound("*jump", CHAN_BODY);
			}
		}
	}

	override
	void CheckCrouch(bool totallyfrozen){
		UserCmd cmd=Player.cmd;
		bool CrouchBtn=cmd.buttons & BT_CROUCH;

		if(CrouchBtn)cmd.buttons&=~BT_JUMP;
		if(CanCrouch() && Player.Health>0 && level.IsCrouchingAllowed())
			if(!TotallyFrozen){
				int CrouchDir=Player.Crouching;

				if(CrouchDir==0)CrouchDir=CrouchBtn?-1:1;
				else if(CrouchBtn)Player.Crouching=0;

				if(CrouchDir==1 && Player.CrouchFactor<1 && Pos.Z+Height<ceilingz)CrouchMove(1);
				else if(CrouchDir==-1 && Player.CrouchFactor>0.5)CrouchMove(-1);
			}
		else Player.Uncrouch();
		Player.CrouchOffset=-ViewHeight*(1-Player.CrouchFactor);
	}

    virtual
	void SoftenFall(){
		if(Vel.Z<=-MStats.ThrustPower){
			FLineTraceData Data;
			Trace(Data, 128, 90);
			if (Data.Distance+Vel.Z<=30)
				if (MidAir){
					MidAir=false;
					Vel.Z+=MStats.ThrustPower;
				}
			else MidAir=true;
		}
	}

    virtual
	void LowerFriction()
	{Friction=(Player.OnGround && !(Player.cmd.buttons & (BT_FORWARD|BT_BACK|BT_MOVELEFT|BT_MOVERIGHT)))?.75:1;}

    virtual
	void CheckCollisionDamage(){
		int Dam;
		if((Dam=LastVelLength-Vel.Length())>40)
			if(bSkullfly)Vel.xy=-50*ViewVector.xy;
			else DamageMobj(self, self, 100, 'Collision', DMG_THRUSTLESS);
		LastVelLength=Vel.Length();
	}
}