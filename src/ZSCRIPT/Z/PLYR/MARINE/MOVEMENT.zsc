extend
class ZMarine{
    override
    void HandleArmorMovement()
    {MStats.HandleMovement(self);}

    override
    double GetAirControl()
    {return 5/11.;}

    override
    double CheckSprint(){
        if(!Player.OnGround)return 1;
        // Sprinting
        if((~Buttons & BT_BACK) && (~Buttons & BT_CROUCH) && (Buttons & BT_SPEED) && (Buttons & BT_FORWARD) && (Health>=RunHealth) && (MStats.Energy>MStats.SprintCost)){
            MStats.Recharger=0;
            MStats.Energy-=MStats.SprintCost;
            return MStats.SprintMultiplier;
        // Backstep
        }else if(Buttons & BT_BACK)return SideMove1;
        else return 1;
    }

    override
    void CheckClamber(){
        Vector3 LastPos=Pos;
        SetXYZ(Pos+(0, 0, MaxLedgeHeight));
        LedgeHeight=GetZAt(Radius+4)-LastPos.Z;
        SetXYZ(LastPos);
        bool Jumping=Buttons & BT_JUMP;
        if(!MidClamber){
            MidClamber=Player.JumpTics!=0 && (Vel.Z<=0) && LedgeHeight>(Player.CrouchOffset!=0)*MaxStepHeight && LedgeHeight<=MaxLedgeHeight;
        }else{
            if(LedgeHeight>MaxLedgeHeight)MidClamber=false;
            else if(LedgeHeight<=MaxStepHeight){
                MidClamber=false;
                Vel.xy+=2*FrontVector;
            }
        }
        if(MidClamber)Vel=(0, 0, (ledgeHeight<=maxStepHeight)?0:MStats.ClamberSpeed);
    }

    override
    bool CanCollideWith(Actor Other, bool Passive){
        bool Result=super.CanCollideWith(Other, Passive);
        if(Result && bSkullfly && Vel.XY.Length()>=15 && Other.bSOLID){
            Other.DamageMobj(self, self, 1.5*Vel.XY.Length()*sqrt(Vel.XY.Length()/30.), 'Charge');
            // TODO: Take monster mass/size into account. Continue through weak ones and stop at larger ones?
            Vel.xy=Vel.xy dot SideVector*SideVector;
            bSkullfly=false;
        }
        return Result;
    }
}