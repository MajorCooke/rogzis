class ZMStats:Thinker{
    transient
    int OldStats,
        Recharger;

    bool DashAvailable;

    int Intelligence,
        Willpower,
        Endurance,
        Strength,
        Defense,
        Agility,
        Luck,
        
        MaxStrain,

        //Health
        Health,
        MaxHealth,
        RunHealth,
        BaseHealth,

        //Plating
        Plate,
        MaxPlate,
        PlateAbsorption,
        BasePlateAbsorption,

        //Energy
        Energy,
        MaxEnergy,
        BaseEnergy,
        IdleRechargeBonus,
        EnergyRechargeRate,
        EnergyRechargeAmount,

        //Magnetic Repulsion
        Magnet,
        MaxMagnet,
        MagnetRechargeRate,
        MagnetRechargeAmount,

        //Plasma Shield
        Shield,
        MaxShield,
        ShieldDivider,
        ShieldRechargeRate,
        ShieldRechargeAmount,

        //Hard Light Construct
        Light,
        MaxLight,
        LightChargeUp,
        LightRechargeRate,
        LightRechargeAmount,

        SprintCost,
        SprintMultiplier;

    double ForwardMove1,
           ForwardMove2,
           BaseForwardMove,
           SideMove1,
           SideMove2,
           BaseSideMove,
           ViewBob,
           JumpZ,
           BaseJumpZ,
           ClamberSpeed,
           CriticalChance,

           ShakeLevel,
           BaseShakeLevel;

    ZArmorInfo Info;
    Array<bool> UpgradesActivated;
    Array<ZMArmorUpgrade> Upgrades;

    static
    ZMStats Instance(){
        ThinkerIterator it=ThinkerIterator.Create("ZMStats", STAT_STATIC);
        ZMStats p=ZMStats(it.Next());
        if(!p)p=new("ZMStats").Init();
        return p;
    }

    private
    ZMStats Init(){
        ChangeStatNum(STAT_STATIC);
        Parser_Zinf Config=ZManager.Config();
        //Attributes
        Intelligence=
        Willpower=
        Endurance=
        Strength=
        Defense=
        Agility=
        Luck=0;
        //Stats
        ForwardMove2=(ViewBob=ForwardMove1=BaseForwardMove=.65)/2;
        SideMove2=(SideMove1=BaseSideMove=.52)/2;
        JumpZ=BaseJumpZ=7;
        ClamberSpeed=1;
        Health=Config.GetInt("HEALTH","iSTART_HEALTH");
        MaxHealth=BaseHealth=Config.GetInt("HEALTH","iMAX_HEALTH");
        RunHealth=floor(MaxHealth*Config.GetDouble("HEALTH","dRUN_HEALTH_PERC"));
        MaxPlate=Plate=Config.GetInt("ARMOR", "iSTART_PLATE");
        PlateAbsorption=BasePlateAbsorption=Config.GetDouble("ARMOR","dPLATE_ABSORPTION");
        MaxEnergy=BaseEnergy=Energy=Config.GetInt("ABILITIES", "iMAX_ENERGY");
        EnergyRechargeRate=MaxEnergy/2;
        EnergyRechargeAmount=20;
        IdleRechargeBonus=2;
        SprintCost=Config.GetInt("ABILITIES", "iSPRINT_COST");
        SprintMultiplier=Config.GetDouble("ABILITIES", "dSPRINT_MULTIPLIER");
        ShakeLevel=BaseShakeLevel=5;
        Info=AMR_ENERGY;
        //Inventory
        MaxStrain=20;
        AddUpgrade("BoostJump");
        AddUpgrade("BoostDash");
        AddUpgrade("LongFall");
        AddUpgrade("Glide");
        ToggleUpgrade("BoostJump");
        ToggleUpgrade("BoostDash");
        ToggleUpgrade("LongFall");
        ToggleUpgrade("Glide");
        return self;
    }

    int, int, int GetHealth() const
    {return Health, MaxHealth, RunHealth;}

    double, double, double GetForwardMove() const
    {return ForwardMove1, ForwardMove2, SprintMultiplier;}

    double, double GetSideMove() const
    {return SideMove1, SideMove2;}

    int GetStrain() const{
        int TotalStrain=0;
        for(int i=0; i<Upgrades.Size(); i++)
            if(UpgradesActivated[i])
                TotalStrain+=Upgrades[i].Strain;
        return TotalStrain;
    }

    void UpdateStats(){
        PlateAbsorption=(1+.12*Min(Defense, 25))*BasePlateAbsorption;
        MaxMagnet=4*Clamp(Defense-25, 0, 25);
        MaxShield=4*Clamp(Defense-50, 0, 25);
        MaxLight=4*Clamp(Defense-75, 0, 25);
        MaxEnergy=(1+.04*Endurance)*BaseEnergy;
        ShakeLevel=(1-.001*(Willpower+Strength))*BaseShakeLevel;
        ForwardMove2=(ViewBob=ForwardMove1=(1+.01*Agility)*BaseForwardMove)/2;
        SideMove2=(SideMove1=(1+.01*Agility)*BaseSideMove)/2;
        JumpZ=.015*(Strength+Agility)+BaseJumpZ;
        ClamberSpeed=1+.02*(Strength+Agility);
        CriticalChance=.001*Luck;
    }

    bool AddUpgrade(Name ID){
        ZMArmorUpgrade Upgrade=ZMArmorUpgrade(ZManager.Upgrade(UPR_MARMOR, ID));
        if(Upgrades.Find(Upgrade)!=Upgrades.Size())return false;
        Upgrades.Push(Upgrade);
        UpgradesActivated.Push(false);
        return true;
    }

    bool ToggleUpgrade(Name ID){
        int Index;
        ZMArmorUpgrade Upgrade=ZMArmorUpgrade(ZManager.Upgrade(UPR_MARMOR, ID));
        if(!Upgrade || Upgrade.Strain+GetStrain()>MaxStrain || (Index=Upgrades.Find(Upgrade))==Upgrades.Size())return false;
        UpgradesActivated[Index]=!UpgradesActivated[Index];
        return true;
    }

    virtual
    void ArmorTick(ZMarine Player){
        for(int i=0; i<Upgrades.Size(); i++)
            if(UpgradesActivated[i])
                Upgrades[i].Tick(Player, Player.Player);
    }

    virtual
    void HandleMovement(ZMarine Player){
        for(int i=0; i<Upgrades.Size(); i++)
            if(UpgradesActivated[i])
                Upgrades[i].HandleMovement(Player, Player.Player);
    }

    virtual
    int Status() const
    {return Health+Energy+Plate+Magnet+Shield+Light;}

    virtual
    void Recharge(ZPlayer Player){
        if(!Player || Player.Health<=0 || ~Info & AMR_ENERGY || Plate<=0)return;
        //This Tick
        int CurrentStats=Status();
        if(CurrentStats>=OldStats){
            int ShieldGoal;
            if(Energy<MaxEnergy){
                if(Recharger==EnergyRechargeRate){
                    Energy=Min(Energy+EnergyRechargeAmount*(Player.Vel==(0,0,0)?IdleRechargeBonus:1), MaxEnergy);
                    if(Energy==MaxEnergy)Recharger=0;
                }else Recharger++;
            }else if((Info & AMR_MAGNET) && Magnet<MaxMagnet){
                if(Recharger==MagnetRechargeRate){
                    Magnet=Min(Magnet+MagnetRechargeAmount*(Player.Vel==(0,0,0)?IdleRechargeBonus:1), MaxMagnet);
                    if(Magnet==MaxMagnet)Recharger=0;
                }else Recharger++;
            }else if((Info & AMR_SHIELD) && Shield<(ShieldGoal=int(Shield/ShieldDivider+1)*ShieldDivider)){
                if(Recharger==ShieldRechargeRate){
                    Shield=Min(Shield+ShieldRechargeAmount*(Player.Vel==(0,0,0)?IdleRechargeBonus:1), ShieldGoal);
                    if(Shield==ShieldGoal)Recharger=0;
                }else Recharger++;
            }else if((Info & AMR_LIGHT) && Light==0){
                if(LightChargeUp==MaxLight){
                    Light=MaxLight;
                    Recharger=LightChargeUp=0;
                }else if(Recharger==LightRechargeRate)
                    LightChargeUp=Min(LightChargeUp+LightRechargeAmount*(Player.Vel==(0,0,0)?IdleRechargeBonus:1), MaxLight);
                else Recharger++;
            }
        }else Recharger=0;
        //Last Tick
        OldStats=Status();
    }

    virtual
    int ModifyDamageGiven(ZWeapon Weapon, int Damage, Name Mod, int Flags=0){
        switch(Mod){
            case 'Melee':
                Damage*=1+.02*Strength;
                break;
        }
        return Damage+(FRandom(0, 1)<=CriticalChance*Weapon.CriticalMultiplier())*Weapon.CriticalDamage;
    }

    virtual
    int ModifyDamageTaken(Actor Inflictor, Actor Source, int Damage, Name Mod, int Flags=0, double Angle=0){
        ZDamageType DamageType=ZManager.DamageType(Mod);
        if(!DamageType){
            ZManager.Error(String.Format("Undefined ZDamageType: %s", Mod), ERR_ERROR);
            return Damage;
        }
        double Dam, TempDamage=Damage;
        //Powered Armor
        if(MaxMagnet>0)
            if((Dam=TempDamage*DamageType.Factor(AMR_MAGNET))>0)
                if(Ceil(Dam)<=Magnet){
                    Magnet-=Dam;
                    return 0;
                }else{
                    TempDamage-=Floor(Magnet/DamageType.Factor(AMR_MAGNET));
                    Magnet=0;
                }
            else if(Dam<0){
                Magnet=Min(Magnet-Ceil(Dam), MaxMagnet);
                return 0;
            }
        if(MaxLight>0)
            if((Dam=TempDamage*DamageType.Factor(AMR_LIGHT))>0)
                if(Ceil(Dam)<=Light){
                    Light-=Dam;
                    return 0;
                }else{
                    TempDamage-=Floor(Light/DamageType.Factor(AMR_LIGHT));
                    Light=0;
                }
            else if(Dam<0){
                Light=Min(Light-Ceil(Dam), MaxLight);
                return 0;
            }
        if(MaxShield>0)
            if((Dam=TempDamage*DamageType.Factor(AMR_SHIELD))>0)
                if(Ceil(Dam)<=Shield){
                    Shield-=Dam;
                    return 0;
                }else{
                    TempDamage-=Floor(Shield/DamageType.Factor(AMR_SHIELD));
                    Shield=0;
                }
            else if(Dam<0){
                Shield=Min(Shield-Ceil(Dam), MaxShield);
                return 0;
            }
        int PlateHit;
        //Armor Plating
        if((Info & AMR_PLATE)){
            if((Dam=TempDamage*DamageType.Factor(AMR_PLATE))>0){
                TempDamage*=1-Floor(PlateHit=PlateAbsorption*ZCalc.DRangeMap(Plate/MaxPlate, 0, 1, 0, 1.5));
                Plate=Max(Plate-PlateHit, 0);
            }
        }else Plate=Max(Plate-Ceil(TempDamage/2), 0);
        return Ceil(TempDamage);
    }
}